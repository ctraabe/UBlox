/*******************************************************************************
*
* This file opens the connection to the ublox LEA-6S on the MKGPS V2.1 and
* configures it the same as would be the case when connected to a NaviCtrl.
*
*******************************************************************************/

#include <chrono>
#include <csignal>
#include <iomanip>
#include <iostream>
#include <thread>

#include "serial.hpp"

volatile sig_atomic_t g_signal_status = 0;

void signal_handler(int signal)
{
  g_signal_status = signal;
}

int main(int argc, const char* argv[])
{
  std::signal(SIGINT, signal_handler);

  {
    // Device starts in 9600 BAUD.
    Serial serial_gps("/dev/ttyUSB0", 9600);

    // Set the port to UART UBX @ 57600.
    uint8_t tx_buffer[28] = { 0xb5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00,
      0x00, 0x00, 0xd0, 0x08, 0x00, 0x00, 0x00, 0xe1, 0x00, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x8d };
    serial_gps.SendBuffer(tx_buffer, 28);

    // Wait a moment to let the RX buffer fill with whatever was being output
    // before the port was set.
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // Clear the RX buffer.
    uint8_t rx_buffer[1024];
    while (serial_gps && serial_gps.Read(rx_buffer, 1024)) continue;

    serial_gps.Close();
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
  }

  // Reopen the port at 57600.
  Serial serial_gps("/dev/ttyUSB0", 57600);

  {  // Request version.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x0a, 0x04, 0x00, 0x00, 0x0e, 0x34 };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {  // Configure USB for UBX input with no output.
    uint8_t tx_buffer[28] = { 0xb5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x03, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x8c };
    serial_gps.SendBuffer(tx_buffer, 28);
  }
  {  // Set antenna flags to 0x0b and pins to 0x380f.
    uint8_t tx_buffer[12] = { 0xb5, 0x62, 0x06, 0x13, 0x04, 0x00, 0x0b, 0x00,
      0x0f, 0x38, 0x6f, 0x4f };
    serial_gps.SendBuffer(tx_buffer, 12);
  }
  {  // Set measurement period to 200ms (5Hz) with UTC reference.
    uint8_t tx_buffer[14] = { 0xb5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xc8, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xdd, 0x68 };
    serial_gps.SendBuffer(tx_buffer, 14);
  }
  {  // Configure TimPulse.
    uint8_t tx_buffer[28] = { 0xb5, 0x62, 0x06, 0x07, 0x14, 0x00, 0x40, 0x42,
      0x0f, 0x00, 0x90, 0x86, 0x03, 0x00, 0xff, 0x01, 0x00, 0x00, 0x32, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x70 };
    serial_gps.SendBuffer(tx_buffer, 28);
  }
  {  // Configure SBAS.
    uint8_t tx_buffer[16] = { 0xb5, 0x62, 0x06, 0x16, 0x08, 0x00, 0x03, 0x03,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0xbd };
    serial_gps.SendBuffer(tx_buffer, 16);
  }
  {  // Configure navigation engine.
    uint8_t tx_buffer[44] = { 0xb5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xff, 0xff,
      0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x08, 0x3c,
      0x50, 0x00, 0x32, 0x00, 0x23, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0xfa };
    serial_gps.SendBuffer(tx_buffer, 44);
  }
  {  // Configure navigation engine expert settings.
    uint8_t tx_buffer[48] = { 0xb5, 0x62, 0x06, 0x23, 0x28, 0x00, 0x00, 0x00,
      0x4c, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x14, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xf8, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xc9, 0xea };
    serial_gps.SendBuffer(tx_buffer, 48);
  }
  {  // Request NAV-POSLLH message to be output every measurement cycle.
    uint8_t tx_buffer[11] = { 0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0x01, 0x02,
      0x01, 0x0e, 0x47 };
    serial_gps.SendBuffer(tx_buffer, 11);
  }
  {  // Request NAV-SOL message to be output every measurement cycle.
    uint8_t tx_buffer[11] = { 0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0x01, 0x06,
      0x01, 0x12, 0x4f };
    serial_gps.SendBuffer(tx_buffer, 11);
  }
  {  // Request NAV-VELNED message to be output every measurement cycle.
    uint8_t tx_buffer[11] = { 0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0x01, 0x12,
      0x01, 0x1e, 0x67 };
    serial_gps.SendBuffer(tx_buffer, 11);
  }
/*
  {
    // Request antenna settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x13, 0x00, 0x00, 0x19, 0x51 };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request datum settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x06, 0x00, 0x00, 0x0c, 0x2a };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request measurement rate settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x08, 0x00, 0x00, 0x0e, 0x30 };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request information message configuration settings.
    uint8_t tx_buffer[9] = { 0xb5, 0x62, 0x06, 0x02, 0x01, 0x00, 0x00, 0x09, 0x29 };
    serial_gps.SendBuffer(tx_buffer, 9);
  }
  {
    // Request time pulse settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x07, 0x00, 0x00, 0x0d, 0x2d };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request SBAS settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x16, 0x00, 0x00, 0x1c, 0x5a };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request Nav engine settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x24, 0x00, 0x00, 0x2a, 0x84 };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request Nav engine expert settings.
    uint8_t tx_buffer[8] = { 0xb5, 0x62, 0x06, 0x23, 0x00, 0x00, 0x29, 0x81 };
    serial_gps.SendBuffer(tx_buffer, 8);
  }
  {
    // Request UART2 settings.
    uint8_t tx_buffer[9] = { 0xb5, 0x62, 0x06, 0x00, 0x01, 0x00, 0x02, 0x09, 0x23 };
    serial_gps.SendBuffer(tx_buffer, 9);
  }
  {
    // Request USB settings.
    uint8_t tx_buffer[9] = { 0xb5, 0x62, 0x06, 0x00, 0x01, 0x00, 0x03, 0x0a, 0x24 };
    serial_gps.SendBuffer(tx_buffer, 9);
  }
*/
  while (!g_signal_status)
  {
    uint8_t rx_buffer[256];
    int bytes_read = serial_gps.Read(rx_buffer, 256);

    for (int i = 0; i < bytes_read; ++i)
    {
      std::cout << " 0x" << std::hex << std::setfill('0') << std::setw(2)
        << (int)rx_buffer[i];
    }
    std::cout << std::endl;

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }
  std::cout << std::endl;

  serial_gps.Close();
}